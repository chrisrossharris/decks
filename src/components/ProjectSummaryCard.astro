---
import { parseJsonObject } from '@/lib/utils/json';
import { money } from '@/lib/utils/format';

interface Props {
  inputs?: any;
  takeoff?: any;
  labor?: any;
  estimate?: any;
}

const { inputs = {}, takeoff, labor, estimate } = Astro.props as Props;

const polygonPoints = Array.isArray(inputs.deck_polygon_points)
  ? inputs.deck_polygon_points
      .map((p: any) => ({ x: Number(p?.x), y: Number(p?.y) }))
      .filter((p: any) => Number.isFinite(p.x) && Number.isFinite(p.y))
  : [];
const isPolygon = inputs.shape_mode === 'polygon' && polygonPoints.length >= 3;
const polygonBounds = isPolygon
  ? {
      minX: Math.min(...polygonPoints.map((p: any) => p.x)),
      maxX: Math.max(...polygonPoints.map((p: any) => p.x)),
      minY: Math.min(...polygonPoints.map((p: any) => p.y)),
      maxY: Math.max(...polygonPoints.map((p: any) => p.y))
    }
  : null;
const lengthFt = Number(isPolygon && polygonBounds ? polygonBounds.maxX - polygonBounds.minX : inputs.deck_length_ft ?? 0);
const widthFt = Number(isPolygon && polygonBounds ? polygonBounds.maxY - polygonBounds.minY : inputs.deck_width_ft ?? 0);
const joistSpacingInInput = Number(inputs.joist_spacing_in ?? 16);
const joistSpacingIn = String(inputs.decking_material ?? '') === 'composite'
  ? Math.min(joistSpacingInInput, 12)
  : joistSpacingInInput;
const deckingMaterial = String(inputs.decking_material ?? 'wood');
const joistCount = Math.max(2, Math.ceil((Math.max(lengthFt, 1) * 12) / Math.max(joistSpacingIn, 1)));
const drawJoists = Math.max(2, Math.min(24, joistCount));
const beamCountInput = Math.max(1, Number(inputs.beam_count ?? 1));
const postSpacingFt = Math.max(1, Number(inputs.post_spacing_ft ?? 6));

const items = Array.isArray(takeoff?.items) ? takeoff.items : [];
const postItem = items.find((i: any) => i.category === 'Footings' && String(i.name ?? '').includes('PT structural post'));
const bagItem = items.find((i: any) => i.category === 'Footings' && i.name === 'Concrete bag');
const railingItem = items.find((i: any) => i.category === 'Railing' && String(i.name ?? '').startsWith('Railing -'));

const structuralPosts = Number(postItem?.qty ?? 0);
const concreteBags = Number(bagItem?.qty ?? 0);
const railingLf = Number(railingItem?.qty ?? 0);
const parsedTotals = parseJsonObject(takeoff?.totals_json, {} as Record<string, unknown>);
const deckSqft = Number(
  (parsedTotals as any).deck_sqft ??
  takeoff?.totals?.deck_sqft ??
  (Number(inputs.deck_length_ft ?? 0) * Number(inputs.deck_width_ft ?? 0))
);
const laborTotal = Number(labor?.total_labor_cost ?? 0);
const totalPrice = Number(estimate?.grand_total ?? 0);
const assumptions = parseJsonObject(takeoff?.assumptions_json, {} as Record<string, unknown>);
const constants = parseJsonObject((assumptions as any).constants, {} as Record<string, unknown>);
const beamCountEffectiveRaw = Number((constants as any).effective_beam_count ?? 0);
const beamCount = Number.isFinite(beamCountEffectiveRaw) && beamCountEffectiveRaw > 0
  ? Math.max(1, beamCountEffectiveRaw)
  : beamCountInput;
const railingPostSpacingFt = Math.max(1, Number((constants as any).default_railing_post_spacing_ft ?? 6));
const beamSupportPostsRaw = Number((constants as any).beam_support_post_count ?? 0);
const beamSupportPosts = Number.isFinite(beamSupportPostsRaw) && beamSupportPostsRaw > 0
  ? beamSupportPostsRaw
  : Math.max(4, (Math.ceil(Math.max(lengthFt, 1) / postSpacingFt) + 1) * beamCountInput);
const perimeterSupportPostsRaw = Number((constants as any).perimeter_railing_support_post_count ?? 0);
const railingSupportRunRaw = Number((constants as any).railing_support_run_lf ?? 0);
const ledgerSideRaw = String((inputs as any).ledger_side ?? (constants as any).ledger_side ?? 'top').toLowerCase();
const ledgerSide = (ledgerSideRaw === 'right' || ledgerSideRaw === 'bottom' || ledgerSideRaw === 'left') ? ledgerSideRaw : 'top';
const ledgerLineIndexRaw = Number((inputs as any).ledger_line_index ?? (constants as any).ledger_line_index ?? -1);
const ledgerLineIndex = isPolygon && Number.isFinite(ledgerLineIndexRaw) && ledgerLineIndexRaw >= 0
  ? Math.floor(ledgerLineIndexRaw) % Math.max(1, polygonPoints.length)
  : null;
const polygonHouseSideLengthFt = isPolygon && ledgerLineIndex !== null
  ? Math.hypot(
      (polygonPoints[(ledgerLineIndex + 1) % polygonPoints.length]?.x ?? 0) - (polygonPoints[ledgerLineIndex]?.x ?? 0),
      (polygonPoints[(ledgerLineIndex + 1) % polygonPoints.length]?.y ?? 0) - (polygonPoints[ledgerLineIndex]?.y ?? 0)
    )
  : 0;
const houseSideLengthFt = isPolygon
  ? polygonHouseSideLengthFt
  : (ledgerSide === 'left' || ledgerSide === 'right') ? Math.max(widthFt, 0) : Math.max(lengthFt, 0);
const outFromHouseFt = (ledgerSide === 'left' || ledgerSide === 'right') ? Math.max(lengthFt, 0) : Math.max(widthFt, 0);
const stairOpeningLf = Math.max(0, Number(inputs.stair_count ?? 0) * Number(inputs.stair_width_ft ?? 0));
const openRunFallback = Math.max(
  0,
  (inputs.ledger ? Math.max((2 * (Math.max(lengthFt, 0) + Math.max(widthFt, 0))) - houseSideLengthFt, 0) : (2 * (Math.max(lengthFt, 0) + Math.max(widthFt, 0))))
    - stairOpeningLf
);
const perimeterSupportPosts = Number.isFinite(perimeterSupportPostsRaw) && perimeterSupportPostsRaw > 0
  ? perimeterSupportPostsRaw
  : Math.max(0, Math.ceil(openRunFallback / railingPostSpacingFt) + 1);
const railingSupportRunLf = Number.isFinite(railingSupportRunRaw) && railingSupportRunRaw > 0
  ? railingSupportRunRaw
  : openRunFallback;
const drawBeamPostsPerBeam = Math.max(2, Math.ceil(beamSupportPosts / Math.max(beamCount, 1)));

const frameMaxW = 260;
const frameMaxH = 120;
const frameOriginX = 24;
const frameOriginY = 20;
const scale = Math.min(frameMaxW / Math.max(lengthFt, 1), frameMaxH / Math.max(widthFt, 1));
const drawW = Math.max(40, Math.min(frameMaxW, Math.max(lengthFt, 1) * scale));
const drawH = Math.max(40, Math.min(frameMaxH, Math.max(widthFt, 1) * scale));
const x0 = frameOriginX + (frameMaxW - drawW) / 2;
const y0 = frameOriginY + (frameMaxH - drawH) / 2;
const x1 = x0 + drawW;
const y1 = y0 + drawH;
const joistPitchPx = drawJoists > 1 ? drawW / (drawJoists - 1) : 0;
const polygonScreenPoints = isPolygon && polygonBounds
  ? polygonPoints.map((p: any) => ({
      x: x0 + ((p.x - polygonBounds.minX) / Math.max(1, polygonBounds.maxX - polygonBounds.minX)) * drawW,
      y: y1 - ((p.y - polygonBounds.minY) / Math.max(1, polygonBounds.maxY - polygonBounds.minY)) * drawH
    }))
  : [];
const polygonPointsAttr = polygonScreenPoints.map((p: any) => `${p.x},${p.y}`).join(' ');
const perimeterFt = Math.max(1, Math.max(lengthFt, 1) + 2 * Math.max(widthFt, 1));
const corners = [
  { x: x0, y: y1 }, // bottom-left
  { x: x1, y: y1 }, // bottom-right
  { x: x1, y: y0 }, // top-right (ledger corner)
  { x: x0, y: y0 } // top-left (ledger corner)
];
const perimeterPoints = (() => {
  if (isPolygon) {
    return polygonScreenPoints.slice(0, Math.min(polygonScreenPoints.length, 40));
  }
  const target = Math.max(0, Math.min(40, perimeterSupportPosts));
  if (target <= 0) return [] as Array<{ x: number; y: number }>;
  if (target <= 4) return corners.slice(0, target);

  const remaining = target - 4;
  const allSides = [
    { key: 'bottom', len: Math.max(lengthFt, 1), start: corners[0], end: corners[1] },
    { key: 'right', len: Math.max(widthFt, 1), start: corners[1], end: corners[2] },
    { key: 'top', len: Math.max(lengthFt, 1), start: corners[3], end: corners[2] },
    { key: 'left', len: Math.max(widthFt, 1), start: corners[3], end: corners[0] }
  ];
  const sideDefs = allSides.filter((s) => !(inputs.ledger && s.key === ledgerSide));

  const quotas = sideDefs.map((s) => (remaining * s.len) / perimeterFt);
  const extras = quotas.map((q) => Math.floor(q));
  let allocated = extras.reduce((sum, n) => sum + n, 0);
  const remainders = quotas.map((q, i) => ({ i, rem: q - Math.floor(q) })).sort((a, b) => b.rem - a.rem);
  for (let r = 0; allocated < remaining && r < remainders.length; r += 1) {
    extras[remainders[r].i] += 1;
    allocated += 1;
  }

  const points: Array<{ x: number; y: number }> = [...corners];
  for (let sideIndex = 0; sideIndex < sideDefs.length; sideIndex += 1) {
    const side = sideDefs[sideIndex];
    const count = extras[sideIndex];
    for (let i = 1; i <= count; i += 1) {
      const t = i / (count + 1);
      points.push({
        x: side.start.x + (side.end.x - side.start.x) * t,
        y: side.start.y + (side.end.y - side.start.y) * t
      });
    }
  }

  return points.slice(0, Math.min(target, 40));
})();
const ledgerLine = (() => {
  if (!inputs.ledger) return null;
  if (isPolygon && ledgerLineIndex !== null && polygonScreenPoints.length >= 2) {
    const a = polygonScreenPoints[ledgerLineIndex];
    const b = polygonScreenPoints[(ledgerLineIndex + 1) % polygonScreenPoints.length];
    if (!a || !b) return null;
    return {
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y,
      lx: (a.x + b.x) / 2 - 32,
      ly: (a.y + b.y) / 2 - 8
    };
  }
  if (ledgerSide === 'right') return { x1: x1, y1: y0, x2: x1, y2: y1, lx: x1 - 36, ly: y0 - 8 };
  if (ledgerSide === 'bottom') return { x1: x0, y1: y1, x2: x1, y2: y1, lx: x0, ly: y1 + 12 };
  if (ledgerSide === 'left') return { x1: x0, y1: y0, x2: x0, y2: y1, lx: x0, ly: y0 - 8 };
  return { x1: x0, y1: y0, x2: x1, y2: y0, lx: x0, ly: y0 - 8 };
})();
---

<section class="mb-4 card p-4">
  <h2 class="font-display text-lg font-semibold">Project Summary</h2>
  <p class="mt-1 text-sm text-slate-500">Quick snapshot after takeoff, labor, and estimate.</p>

  <div class="mt-3 grid gap-3 sm:grid-cols-3">
    <div class="surface-muted rounded-md p-3">
      <p class="label">Deck Area</p>
      <p class="text-lg font-semibold">{Number.isFinite(deckSqft) ? deckSqft.toFixed(0) : '0'} sqft</p>
    </div>
    <div class="surface-muted rounded-md p-3">
      <p class="label">Structural Posts / Concrete</p>
      <p class="text-lg font-semibold">{structuralPosts} posts â€¢ {concreteBags} bags</p>
    </div>
    <div class="surface-muted rounded-md p-3">
      <p class="label">Estimate Total</p>
      <p class="text-lg font-semibold">{money(totalPrice)}</p>
    </div>
  </div>

  <div class="mt-4 grid gap-4 lg:grid-cols-[1.3fr_1fr]">
    <div class="surface-muted rounded-md p-3">
      <p class="mb-2 text-sm font-semibold">Mini Diagram</p>
      <svg viewBox="0 0 320 200" class="w-full">
        <defs>
          {isPolygon && polygonPointsAttr && (
            <clipPath id="deck-shape-clip">
              <polygon points={polygonPointsAttr}></polygon>
            </clipPath>
          )}
        </defs>
        {isPolygon && polygonPointsAttr ? (
          <polygon points={polygonPointsAttr} fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.7"></polygon>
        ) : (
          <rect x={x0} y={y0} width={drawW} height={drawH} fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.7"></rect>
        )}
        {ledgerLine && (
          <text x={ledgerLine.lx} y={ledgerLine.ly} font-size="10" fill="#0f766e">
            House / ledger side ({isPolygon ? `edge ${Number(ledgerLineIndex ?? 0) + 1}` : ledgerSide})
          </text>
        )}
        <g clip-path={isPolygon && polygonPointsAttr ? 'url(#deck-shape-clip)' : undefined}>
          {Array.from({ length: drawJoists }).map((_, i) => (
            <line x1={x0 + (drawW * i) / (drawJoists - 1)} y1={y0} x2={x0 + (drawW * i) / (drawJoists - 1)} y2={y1} stroke="#94a3b8" stroke-width="0.8"></line>
          ))}
        </g>
        {drawJoists > 1 && (
          <>
            <line x1={x0} y1={y1 + 10} x2={x0 + joistPitchPx} y2={y1 + 10} stroke="#334155" stroke-width="1" />
            <line x1={x0} y1={y1 + 7} x2={x0} y2={y1 + 13} stroke="#334155" stroke-width="1" />
            <line x1={x0 + joistPitchPx} y1={y1 + 7} x2={x0 + joistPitchPx} y2={y1 + 13} stroke="#334155" stroke-width="1" />
            <text x={x0 + joistPitchPx / 2 - 14} y={y1 + 21} font-size="8" fill="#334155">{joistSpacingIn}" O.C.</text>
          </>
        )}
        <g clip-path={isPolygon && polygonPointsAttr ? 'url(#deck-shape-clip)' : undefined}>
          {Array.from({ length: beamCount }).map((_, i) => (
            <line x1={x0} y1={y1 - (drawH * (i + 1)) / (beamCount + 1)} x2={x1} y2={y1 - (drawH * (i + 1)) / (beamCount + 1)} stroke="#b45309" stroke-width="2"></line>
          ))}
          {Array.from({ length: beamCount }).map((_, b) => {
            const py = y1 - (drawH * (b + 1)) / (beamCount + 1);
            return Array.from({ length: drawBeamPostsPerBeam }).map((__, p) => {
              const px = x0 + (drawW * p) / Math.max(drawBeamPostsPerBeam - 1, 1);
              return <circle cx={px} cy={py} r="2.6" fill="#1d4ed8"></circle>;
            });
          })}
        </g>
        {perimeterPoints.map((p) => (
          <circle cx={p.x} cy={p.y} r="2.2" stroke="#1d4ed8" stroke-width="1" fill="#ffffff"></circle>
        ))}
        {ledgerLine && (
          <line x1={ledgerLine.x1} y1={ledgerLine.y1} x2={ledgerLine.x2} y2={ledgerLine.y2} stroke="#0f766e" stroke-width="3"></line>
        )}
        <text x={x0} y="178" font-size="10" fill="currentColor">Length (along house): {Number.isFinite(houseSideLengthFt) ? houseSideLengthFt.toFixed(1) : '0.0'} ft</text>
        <text x={x0} y="190" font-size="10" fill="currentColor">Depth (out from house): {Number.isFinite(outFromHouseFt) ? outFromHouseFt.toFixed(1) : '0.0'} ft</text>
      </svg>
      <div class="mt-2 flex flex-wrap items-center gap-3 text-xs text-slate-600">
        <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-slate-400"></span>Joist</span>
        <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-amber-700"></span>Beam</span>
        <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-teal-700"></span>Ledger</span>
        <span class="inline-flex items-center gap-1"><span class="h-2 w-2 rounded-full bg-blue-700"></span>Beam support post</span>
        <span class="inline-flex items-center gap-1"><span class="h-2 w-2 rounded-full border border-blue-700 bg-white"></span>Perimeter railing support post</span>
      </div>
    </div>
    <div class="surface-muted rounded-md p-3 text-sm">
      <p class="font-semibold">Key Metrics</p>
      <p class="mt-2">Joist spacing: {joistSpacingIn}" O.C.</p>
      <p>
        Decking: {deckingMaterial === 'composite' ? 'Composite' : 'Wood'}
        {deckingMaterial === 'composite' ? ' (forced max 12" O.C.)' : ''}
      </p>
      <p>Joists: {joistCount}</p>
      <p>Beam lines: {beamCount}{beamCount !== beamCountInput ? ` (auto from ${beamCountInput})` : ''}</p>
      <p>
        Ledger location: {inputs.ledger ? (isPolygon ? `Edge ${Number(ledgerLineIndex ?? 0) + 1}` : ledgerSide) : 'Freestanding / no ledger'}
      </p>
      <p>Beam support posts: {beamSupportPosts}</p>
      <p>Perimeter railing support posts: {perimeterSupportPosts} (open run {railingSupportRunLf.toFixed(0)} lf @ max {railingPostSpacingFt.toFixed(0)}ft, no ledger-edge posts)</p>
      <p>Railing: {Number.isFinite(railingLf) ? railingLf.toFixed(0) : '0'} lf</p>
      <p>Labor total: {money(laborTotal)}</p>
      <p class="mt-3 text-xs text-slate-500">Diagram is conceptual for quick review, not structural engineering.</p>
    </div>
  </div>
</section>
