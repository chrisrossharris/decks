---
import { parseJsonObject } from '@/lib/utils/json';
import { money } from '@/lib/utils/format';

interface Props {
  inputs?: any;
  takeoff?: any;
  labor?: any;
  estimate?: any;
}

const { inputs = {}, takeoff, labor, estimate } = Astro.props as Props;
const isFence = String((inputs as any).design_mode ?? 'deck') === 'fence';

const polygonPoints = Array.isArray(inputs.deck_polygon_points)
  ? inputs.deck_polygon_points
      .map((p: any) => ({ x: Number(p?.x), y: Number(p?.y) }))
      .filter((p: any) => Number.isFinite(p.x) && Number.isFinite(p.y))
  : [];
const isPolygon = inputs.shape_mode === 'polygon' && polygonPoints.length >= 3;
const polygonBounds = isPolygon
  ? {
      minX: Math.min(...polygonPoints.map((p: any) => p.x)),
      maxX: Math.max(...polygonPoints.map((p: any) => p.x)),
      minY: Math.min(...polygonPoints.map((p: any) => p.y)),
      maxY: Math.max(...polygonPoints.map((p: any) => p.y))
    }
  : null;
const lengthFt = Number(isPolygon && polygonBounds ? polygonBounds.maxX - polygonBounds.minX : inputs.deck_length_ft ?? 0);
const widthFt = Number(isPolygon && polygonBounds ? polygonBounds.maxY - polygonBounds.minY : inputs.deck_width_ft ?? 0);
const joistSpacingInInput = Number(inputs.joist_spacing_in ?? 16);
const joistSpacingIn = String(inputs.decking_material ?? '') === 'composite'
  ? Math.min(joistSpacingInInput, 12)
  : joistSpacingInInput;
const deckingMaterial = String(inputs.decking_material ?? 'wood');
const joistCount = Math.max(2, Math.ceil((Math.max(lengthFt, 1) * 12) / Math.max(joistSpacingIn, 1)));
const drawJoists = Math.max(2, Math.min(24, joistCount));
const beamCountInput = Math.max(1, Number(inputs.beam_count ?? 1));
const postSpacingFt = Math.max(1, Number(inputs.post_spacing_ft ?? 6));

const items = Array.isArray(takeoff?.items) ? takeoff.items : [];
const postItem = items.find((i: any) => i.category === 'Footings' && String(i.name ?? '').includes('PT structural post'));
const bagItem = items.find((i: any) => i.category === 'Footings' && i.name === 'Concrete bag');
const railingItem = items.find((i: any) => i.category === 'Railing' && String(i.name ?? '').startsWith('Railing -'));

const structuralPosts = Number(postItem?.qty ?? 0);
const concreteBags = Number(bagItem?.qty ?? 0);
const railingLf = Number(railingItem?.qty ?? 0);
const parsedTotals = parseJsonObject(takeoff?.totals_json, {} as Record<string, unknown>);
const deckSqft = Number(
  (parsedTotals as any).deck_sqft ??
  takeoff?.totals?.deck_sqft ??
  (Number(inputs.deck_length_ft ?? 0) * Number(inputs.deck_width_ft ?? 0))
);
const laborTotal = Number(labor?.total_labor_cost ?? 0);
const totalPrice = Number(estimate?.grand_total ?? 0);
const fenceLengthLf = Number((inputs as any).fence_length_ft ?? 0);
const fenceHeightFt = Number((inputs as any).fence_height_ft ?? 0);
const fencePosts = Number(items.find((i: any) => i.category === 'Fence' && i.name === 'Fence post')?.qty ?? 0);
const fenceRailsLf = Number(items.find((i: any) => i.category === 'Fence' && i.name === 'Fence rail')?.qty ?? 0);
const fenceGates = Number(items.find((i: any) => i.category === 'Fence' && i.name === 'Fence gate allowance')?.qty ?? 0);
const fenceConcreteBags = Number(items.find((i: any) => i.category === 'Fence' && i.name === 'Concrete bag')?.qty ?? 0);
const fenceAreaSqft = Number.isFinite(deckSqft) ? deckSqft : (fenceLengthLf * fenceHeightFt);
const fenceLayout = String((inputs as any).fence_layout ?? 'straight');
const fenceSideA = Math.max(0, Number((inputs as any).fence_side_a_ft ?? 0));
const fenceSideB = Math.max(0, Number((inputs as any).fence_side_b_ft ?? 0));
const fenceSideC = Math.max(0, Number((inputs as any).fence_side_c_ft ?? 0));
const fenceSegments = (() => {
  if (fenceLayout === 'corner' && fenceSideA > 0 && fenceSideB > 0) return [fenceSideA, fenceSideB];
  if (fenceLayout === 'u_shape' && fenceSideA > 0 && fenceSideB > 0 && fenceSideC > 0) return [fenceSideA, fenceSideB, fenceSideC];
  return [Math.max(0, fenceLengthLf)];
})();
const fenceTotalFromSegments = fenceSegments.reduce((sum, value) => sum + value, 0);
const fenceTotalRunLf = fenceTotalFromSegments > 0 ? fenceTotalFromSegments : Math.max(0, fenceLengthLf);
const isCovered = !isFence && Boolean((inputs as any).is_covered);
const roofTypeLabel = String((inputs as any).roof_type ?? 'shed') === 'gable' ? 'Gable' : 'Lean-to';
const roofPitch = String((inputs as any).roof_pitch ?? '4:12');
const roofingMaterial = String((inputs as any).roofing_material ?? 'shingle');
const roofingType = String((inputs as any).roofing_product_type ?? '').trim();
const roofingColor = String((inputs as any).roofing_color ?? '').trim();
const ceilingFinish = String((inputs as any).ceiling_finish ?? 'none');
const fanPlateCount = Math.max(0, Number((inputs as any).ceiling_fan_plate_count ?? 0));
const roofLengthFt = Math.max(0, Number((inputs as any).roof_length_ft ?? 0));
const roofWidthFt = Math.max(0, Number((inputs as any).roof_width_ft ?? 0));
const roofSqft = roofLengthFt > 0 && roofWidthFt > 0 ? roofLengthFt * roofWidthFt : 0;
const fencePlot = (() => {
  const left = 24;
  const right = 296;
  const bottom = 86;
  const top = 24;
  const width = right - left;
  const height = bottom - top;

  if (fenceSegments.length === 1) {
    return [{ x: left, y: 55 }, { x: right, y: 55 }];
  }

  if (fenceSegments.length === 2) {
    const scale = Math.min(width / Math.max(fenceSegments[0], 1), height / Math.max(fenceSegments[1], 1));
    const a = fenceSegments[0] * scale;
    const b = fenceSegments[1] * scale;
    return [
      { x: left, y: bottom },
      { x: left + a, y: bottom },
      { x: left + a, y: bottom - b }
    ];
  }

  const horiz = fenceSegments[0] + fenceSegments[2];
  const scale = Math.min(width / Math.max(horiz, 1), height / Math.max(fenceSegments[1], 1));
  const a = fenceSegments[0] * scale;
  const b = fenceSegments[1] * scale;
  const c = fenceSegments[2] * scale;
  return [
    { x: left, y: bottom },
    { x: left + a, y: bottom },
    { x: left + a, y: bottom - b },
    { x: left + a + c, y: bottom - b }
  ];
})();
const fencePolylinePoints = fencePlot.map((p) => `${p.x},${p.y}`).join(' ');
const fencePostMarkers = (() => {
  const markers: Array<{ x: number; y: number }> = [];
  const safePosts = Math.max(2, Math.min(60, fencePosts || 2));
  let total = 0;
  const lengths: number[] = [];
  for (let i = 1; i < fencePlot.length; i += 1) {
    const a = fencePlot[i - 1];
    const b = fencePlot[i];
    const len = Math.hypot(b.x - a.x, b.y - a.y);
    lengths.push(len);
    total += len;
  }
  if (total <= 0) return markers;
  for (let i = 0; i < safePosts; i += 1) {
    const target = (i / Math.max(safePosts - 1, 1)) * total;
    let remain = target;
    for (let seg = 0; seg < lengths.length; seg += 1) {
      if (remain <= lengths[seg] || seg === lengths.length - 1) {
        const start = fencePlot[seg];
        const end = fencePlot[seg + 1];
        const t = lengths[seg] > 0 ? remain / lengths[seg] : 0;
        markers.push({
          x: start.x + (end.x - start.x) * t,
          y: start.y + (end.y - start.y) * t
        });
        break;
      }
      remain -= lengths[seg];
    }
  }
  return markers;
})();
const assumptions = parseJsonObject(takeoff?.assumptions_json, {} as Record<string, unknown>);
const constants = parseJsonObject((assumptions as any).constants, {} as Record<string, unknown>);
const beamCountEffectiveRaw = Number((constants as any).effective_beam_count ?? 0);
const beamCount = Number.isFinite(beamCountEffectiveRaw) && beamCountEffectiveRaw > 0
  ? Math.max(1, beamCountEffectiveRaw)
  : beamCountInput;
const railingPostSpacingFt = Math.max(1, Number((constants as any).default_railing_post_spacing_ft ?? 6));
const beamSupportPostsRaw = Number((constants as any).beam_support_post_count ?? 0);
const beamSupportPosts = Number.isFinite(beamSupportPostsRaw) && beamSupportPostsRaw > 0
  ? beamSupportPostsRaw
  : Math.max(4, (Math.ceil(Math.max(lengthFt, 1) / postSpacingFt) + 1) * beamCountInput);
const perimeterSupportPostsRaw = Number((constants as any).perimeter_railing_support_post_count ?? 0);
const railingSupportRunRaw = Number((constants as any).railing_support_run_lf ?? 0);
const ledgerSideRaw = String((inputs as any).ledger_side ?? (constants as any).ledger_side ?? 'top').toLowerCase();
const ledgerSide = (ledgerSideRaw === 'right' || ledgerSideRaw === 'bottom' || ledgerSideRaw === 'left') ? ledgerSideRaw : 'top';
const ledgerLineIndexRaw = Number((inputs as any).ledger_line_index ?? (constants as any).ledger_line_index ?? -1);
const ledgerLineIndex = isPolygon && Number.isFinite(ledgerLineIndexRaw) && ledgerLineIndexRaw >= 0
  ? Math.floor(ledgerLineIndexRaw) % Math.max(1, polygonPoints.length)
  : null;
const polygonHouseSideLengthFt = isPolygon && ledgerLineIndex !== null
  ? Math.hypot(
      (polygonPoints[(ledgerLineIndex + 1) % polygonPoints.length]?.x ?? 0) - (polygonPoints[ledgerLineIndex]?.x ?? 0),
      (polygonPoints[(ledgerLineIndex + 1) % polygonPoints.length]?.y ?? 0) - (polygonPoints[ledgerLineIndex]?.y ?? 0)
    )
  : 0;
const houseSideLengthFt = isPolygon
  ? polygonHouseSideLengthFt
  : (ledgerSide === 'left' || ledgerSide === 'right') ? Math.max(widthFt, 0) : Math.max(lengthFt, 0);
const outFromHouseFt = (ledgerSide === 'left' || ledgerSide === 'right') ? Math.max(lengthFt, 0) : Math.max(widthFt, 0);
const stairOpeningLf = Math.max(0, Number(inputs.stair_count ?? 0) * Number(inputs.stair_width_ft ?? 0));
const openRunFallback = Math.max(
  0,
  (inputs.ledger ? Math.max((2 * (Math.max(lengthFt, 0) + Math.max(widthFt, 0))) - houseSideLengthFt, 0) : (2 * (Math.max(lengthFt, 0) + Math.max(widthFt, 0))))
    - stairOpeningLf
);
const perimeterSupportPosts = Number.isFinite(perimeterSupportPostsRaw) && perimeterSupportPostsRaw > 0
  ? perimeterSupportPostsRaw
  : Math.max(0, Math.ceil(openRunFallback / railingPostSpacingFt) + 1);
const railingSupportRunLf = Number.isFinite(railingSupportRunRaw) && railingSupportRunRaw > 0
  ? railingSupportRunRaw
  : openRunFallback;
const drawBeamPostsPerBeam = Math.max(2, Math.ceil(beamSupportPosts / Math.max(beamCount, 1)));

const frameMaxW = 260;
const frameMaxH = 120;
const frameOriginX = 24;
const frameOriginY = 20;
const scale = Math.min(frameMaxW / Math.max(lengthFt, 1), frameMaxH / Math.max(widthFt, 1));
const drawW = Math.max(40, Math.min(frameMaxW, Math.max(lengthFt, 1) * scale));
const drawH = Math.max(40, Math.min(frameMaxH, Math.max(widthFt, 1) * scale));
const x0 = frameOriginX + (frameMaxW - drawW) / 2;
const y0 = frameOriginY + (frameMaxH - drawH) / 2;
const x1 = x0 + drawW;
const y1 = y0 + drawH;
const joistPitchPx = drawJoists > 1 ? drawW / (drawJoists - 1) : 0;
const polygonScreenPoints = isPolygon && polygonBounds
  ? polygonPoints.map((p: any) => ({
      x: x0 + ((p.x - polygonBounds.minX) / Math.max(1, polygonBounds.maxX - polygonBounds.minX)) * drawW,
      y: y1 - ((p.y - polygonBounds.minY) / Math.max(1, polygonBounds.maxY - polygonBounds.minY)) * drawH
    }))
  : [];
const polygonPointsAttr = polygonScreenPoints.map((p: any) => `${p.x},${p.y}`).join(' ');
const perimeterFt = Math.max(1, Math.max(lengthFt, 1) + 2 * Math.max(widthFt, 1));
const corners = [
  { x: x0, y: y1 }, // bottom-left
  { x: x1, y: y1 }, // bottom-right
  { x: x1, y: y0 }, // top-right (ledger corner)
  { x: x0, y: y0 } // top-left (ledger corner)
];
const perimeterPoints = (() => {
  if (isPolygon) {
    return polygonScreenPoints.slice(0, Math.min(polygonScreenPoints.length, 40));
  }
  const target = Math.max(0, Math.min(40, perimeterSupportPosts));
  if (target <= 0) return [] as Array<{ x: number; y: number }>;
  if (target <= 4) return corners.slice(0, target);

  const remaining = target - 4;
  const allSides = [
    { key: 'bottom', len: Math.max(lengthFt, 1), start: corners[0], end: corners[1] },
    { key: 'right', len: Math.max(widthFt, 1), start: corners[1], end: corners[2] },
    { key: 'top', len: Math.max(lengthFt, 1), start: corners[3], end: corners[2] },
    { key: 'left', len: Math.max(widthFt, 1), start: corners[3], end: corners[0] }
  ];
  const sideDefs = allSides.filter((s) => !(inputs.ledger && s.key === ledgerSide));

  const quotas = sideDefs.map((s) => (remaining * s.len) / perimeterFt);
  const extras = quotas.map((q) => Math.floor(q));
  let allocated = extras.reduce((sum, n) => sum + n, 0);
  const remainders = quotas.map((q, i) => ({ i, rem: q - Math.floor(q) })).sort((a, b) => b.rem - a.rem);
  for (let r = 0; allocated < remaining && r < remainders.length; r += 1) {
    extras[remainders[r].i] += 1;
    allocated += 1;
  }

  const points: Array<{ x: number; y: number }> = [...corners];
  for (let sideIndex = 0; sideIndex < sideDefs.length; sideIndex += 1) {
    const side = sideDefs[sideIndex];
    const count = extras[sideIndex];
    for (let i = 1; i <= count; i += 1) {
      const t = i / (count + 1);
      points.push({
        x: side.start.x + (side.end.x - side.start.x) * t,
        y: side.start.y + (side.end.y - side.start.y) * t
      });
    }
  }

  return points.slice(0, Math.min(target, 40));
})();
const ledgerLine = (() => {
  if (!inputs.ledger) return null;
  if (isPolygon && ledgerLineIndex !== null && polygonScreenPoints.length >= 2) {
    const a = polygonScreenPoints[ledgerLineIndex];
    const b = polygonScreenPoints[(ledgerLineIndex + 1) % polygonScreenPoints.length];
    if (!a || !b) return null;
    return {
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y,
      lx: (a.x + b.x) / 2 - 32,
      ly: (a.y + b.y) / 2 - 8
    };
  }
  if (ledgerSide === 'right') return { x1: x1, y1: y0, x2: x1, y2: y1, lx: x1 - 36, ly: y0 - 8 };
  if (ledgerSide === 'bottom') return { x1: x0, y1: y1, x2: x1, y2: y1, lx: x0, ly: y1 + 12 };
  if (ledgerSide === 'left') return { x1: x0, y1: y0, x2: x0, y2: y1, lx: x0, ly: y0 - 8 };
  return { x1: x0, y1: y0, x2: x1, y2: y0, lx: x0, ly: y0 - 8 };
})();
---

<section class="mb-4 card p-4">
  <h2 class="font-display text-lg font-semibold">Project Summary</h2>
  <p class="mt-1 text-sm text-slate-500">Quick snapshot after takeoff, labor, and estimate.</p>

  {isFence ? (
    <>
      <div class="mt-3 grid gap-3 sm:grid-cols-3">
        <div class="surface-muted rounded-md p-3">
          <p class="label">Fence Area</p>
          <p class="text-lg font-semibold">{Number.isFinite(fenceAreaSqft) ? fenceAreaSqft.toFixed(0) : '0'} sqft</p>
        </div>
        <div class="surface-muted rounded-md p-3">
          <p class="label">Fence Posts / Concrete</p>
          <p class="text-lg font-semibold">{fencePosts} posts • {fenceConcreteBags} bags</p>
        </div>
        <div class="surface-muted rounded-md p-3">
          <p class="label">Estimate Total</p>
          <p class="text-lg font-semibold">{money(totalPrice)}</p>
        </div>
      </div>
      <div class="mt-4 grid gap-4 lg:grid-cols-[1.3fr_1fr]">
        <div class="surface-muted rounded-md p-3">
          <p class="mb-2 text-sm font-semibold">Fence Diagram</p>
          <svg viewBox="0 0 320 120" class="w-full">
            <polyline points={fencePolylinePoints} fill="none" stroke="#7c2d12" stroke-width="2.5"></polyline>
            {fencePostMarkers.map((p) => (
              <line x1={p.x} y1={p.y - 10} x2={p.x} y2={p.y + 10} stroke="#1d4ed8" stroke-width="2"></line>
            ))}
            <text x="24" y="95" font-size="10" fill="currentColor">Fence run: {fenceTotalRunLf.toFixed(1)} lf</text>
            <text x="24" y="108" font-size="10" fill="currentColor">Height: {fenceHeightFt.toFixed(1)} ft</text>
          </svg>
          <div class="mt-2 flex flex-wrap items-center gap-3 text-xs text-slate-600">
            <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-amber-700"></span>Fence rail line</span>
            <span class="inline-flex items-center gap-1"><span class="h-4 w-0.5 bg-blue-700"></span>Fence post</span>
          </div>
        </div>
        <div class="surface-muted rounded-md p-3 text-sm">
          <p class="font-semibold">Key Metrics</p>
          <p class="mt-2">Fence length: {fenceLengthLf.toFixed(1)} lf</p>
          <p>Layout: {fenceLayout === 'u_shape' ? 'U-shape' : fenceLayout === 'corner' ? 'Corner (L)' : 'Straight'}</p>
          {fenceLayout === 'corner' && fenceSideA > 0 && fenceSideB > 0 && (
            <p>Segments: A {fenceSideA.toFixed(1)} ft + B {fenceSideB.toFixed(1)} ft</p>
          )}
          {fenceLayout === 'u_shape' && fenceSideA > 0 && fenceSideB > 0 && fenceSideC > 0 && (
            <p>Segments: A {fenceSideA.toFixed(1)} ft + B {fenceSideB.toFixed(1)} ft + C {fenceSideC.toFixed(1)} ft</p>
          )}
          <p>Fence height: {fenceHeightFt.toFixed(1)} ft</p>
          <p>Fence style: {String((inputs as any).fence_style ?? 'privacy')}</p>
          <p>Fence material: {String((inputs as any).fence_material ?? 'wood')}</p>
          <p>Fence rails: {fenceRailsLf.toFixed(0)} lf</p>
          <p>Gate count: {fenceGates.toFixed(0)}</p>
          <p>Labor total: {money(laborTotal)}</p>
          <p class="mt-3 text-xs text-slate-500">Fence diagram is conceptual for quick review.</p>
        </div>
      </div>
    </>
  ) : (
    <>
      <div class="mt-3 grid gap-3 sm:grid-cols-2 xl:grid-cols-4">
        <div class="surface-muted rounded-md p-3">
          <p class="label">Deck Area</p>
          <p class="text-lg font-semibold">{Number.isFinite(deckSqft) ? deckSqft.toFixed(0) : '0'} sqft</p>
        </div>
        <div class="surface-muted rounded-md p-3">
          <p class="label">Decking / Joists</p>
          <p class="text-lg font-semibold">{deckingMaterial === 'composite' ? 'Composite' : 'Wood'} • {joistSpacingIn}" O.C.</p>
        </div>
        <div class="surface-muted rounded-md p-3">
          <p class="label">Structural Posts / Concrete</p>
          <p class="text-lg font-semibold">{structuralPosts} posts • {concreteBags} bags</p>
        </div>
        <div class="surface-muted rounded-md p-3">
          <p class="label">Estimate Total</p>
          <p class="text-lg font-semibold">{money(totalPrice)}</p>
        </div>
      </div>
      {isCovered && (
        <div class="mt-3 grid gap-3 sm:grid-cols-2 xl:grid-cols-4">
          <div class="surface-muted rounded-md p-3">
            <p class="label">Roof Package</p>
            <p class="text-lg font-semibold">{roofTypeLabel} • {roofPitch}</p>
          </div>
          <div class="surface-muted rounded-md p-3">
            <p class="label">Roofing</p>
            <p class="text-lg font-semibold">{roofingMaterial}{roofingType ? ` • ${roofingType}` : ''}</p>
          </div>
          <div class="surface-muted rounded-md p-3">
            <p class="label">Ceiling</p>
            <p class="text-lg font-semibold">{ceilingFinish === 'none' ? 'None' : ceilingFinish}{fanPlateCount > 0 ? ` • fan plates ${fanPlateCount}` : ''}</p>
          </div>
          <div class="surface-muted rounded-md p-3">
            <p class="label">Roof Area</p>
            <p class="text-lg font-semibold">{roofSqft.toFixed(0)} sqft{roofingColor ? ` • ${roofingColor}` : ''}</p>
          </div>
        </div>
      )}

  <div class="mt-4 grid gap-4 lg:grid-cols-[1.3fr_1fr]">
    <div class="surface-muted rounded-md p-3">
      <p class="mb-2 text-sm font-semibold">Mini Diagram</p>
      <svg viewBox="0 0 320 200" class="w-full">
        <defs>
          {isPolygon && polygonPointsAttr && (
            <clipPath id="deck-shape-clip">
              <polygon points={polygonPointsAttr}></polygon>
            </clipPath>
          )}
        </defs>
        {isPolygon && polygonPointsAttr ? (
          <polygon points={polygonPointsAttr} fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.7"></polygon>
        ) : (
          <rect x={x0} y={y0} width={drawW} height={drawH} fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.7"></rect>
        )}
        {ledgerLine && (
          <text x={ledgerLine.lx} y={ledgerLine.ly} font-size="10" fill="#0f766e">
            House / ledger side ({isPolygon ? `edge ${Number(ledgerLineIndex ?? 0) + 1}` : ledgerSide})
          </text>
        )}
        <g clip-path={isPolygon && polygonPointsAttr ? 'url(#deck-shape-clip)' : undefined}>
          {Array.from({ length: drawJoists }).map((_, i) => (
            <line x1={x0 + (drawW * i) / (drawJoists - 1)} y1={y0} x2={x0 + (drawW * i) / (drawJoists - 1)} y2={y1} stroke="#94a3b8" stroke-width="0.8"></line>
          ))}
        </g>
        {drawJoists > 1 && (
          <>
            <line x1={x0} y1={y1 + 10} x2={x0 + joistPitchPx} y2={y1 + 10} stroke="#334155" stroke-width="1" />
            <line x1={x0} y1={y1 + 7} x2={x0} y2={y1 + 13} stroke="#334155" stroke-width="1" />
            <line x1={x0 + joistPitchPx} y1={y1 + 7} x2={x0 + joistPitchPx} y2={y1 + 13} stroke="#334155" stroke-width="1" />
            <text x={x0 + joistPitchPx / 2 - 14} y={y1 + 21} font-size="8" fill="#334155">{joistSpacingIn}" O.C.</text>
          </>
        )}
        <g clip-path={isPolygon && polygonPointsAttr ? 'url(#deck-shape-clip)' : undefined}>
          {Array.from({ length: beamCount }).map((_, i) => (
            <line x1={x0} y1={y1 - (drawH * (i + 1)) / (beamCount + 1)} x2={x1} y2={y1 - (drawH * (i + 1)) / (beamCount + 1)} stroke="#b45309" stroke-width="2"></line>
          ))}
          {Array.from({ length: beamCount }).map((_, b) => {
            const py = y1 - (drawH * (b + 1)) / (beamCount + 1);
            return Array.from({ length: drawBeamPostsPerBeam }).map((__, p) => {
              const px = x0 + (drawW * p) / Math.max(drawBeamPostsPerBeam - 1, 1);
              return <circle cx={px} cy={py} r="2.6" fill="#1d4ed8"></circle>;
            });
          })}
        </g>
        {perimeterPoints.map((p) => (
          <circle cx={p.x} cy={p.y} r="2.2" stroke="#1d4ed8" stroke-width="1" fill="#ffffff"></circle>
        ))}
        {ledgerLine && (
          <line x1={ledgerLine.x1} y1={ledgerLine.y1} x2={ledgerLine.x2} y2={ledgerLine.y2} stroke="#0f766e" stroke-width="3"></line>
        )}
        <text x={x0} y="178" font-size="10" fill="currentColor">Length (along house): {Number.isFinite(houseSideLengthFt) ? houseSideLengthFt.toFixed(1) : '0.0'} ft</text>
        <text x={x0} y="190" font-size="10" fill="currentColor">Depth (out from house): {Number.isFinite(outFromHouseFt) ? outFromHouseFt.toFixed(1) : '0.0'} ft</text>
      </svg>
      <div class="mt-2 flex flex-wrap items-center gap-3 text-xs text-slate-600">
        <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-slate-400"></span>Joist</span>
        <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-amber-700"></span>Beam</span>
        <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-teal-700"></span>Ledger</span>
        <span class="inline-flex items-center gap-1"><span class="h-2 w-2 rounded-full bg-blue-700"></span>Beam support post</span>
        <span class="inline-flex items-center gap-1"><span class="h-2 w-2 rounded-full border border-blue-700 bg-white"></span>Perimeter railing support post</span>
      </div>
    </div>
    <div class="surface-muted rounded-md p-3 text-sm">
      <p class="font-semibold">Key Metrics</p>
      <p class="mt-2">Joist spacing: {joistSpacingIn}" O.C.</p>
      <p>
        Decking: {deckingMaterial === 'composite' ? 'Composite' : 'Wood'}
        {deckingMaterial === 'composite' ? ' (forced max 12" O.C.)' : ''}
      </p>
      {isCovered && (
        <p>
          Covered package: {roofTypeLabel} {roofPitch} • {roofingMaterial}{roofingType ? ` ${roofingType}` : ''}{roofingColor ? ` (${roofingColor})` : ''}
        </p>
      )}
      {isCovered && (
        <p>
          Ceiling: {ceilingFinish === 'none' ? 'none' : ceilingFinish}{fanPlateCount > 0 ? ` • fan plates ${fanPlateCount}` : ''}
        </p>
      )}
      <p>Joists: {joistCount}</p>
      <p>Beam lines: {beamCount}{beamCount !== beamCountInput ? ` (auto from ${beamCountInput})` : ''}</p>
      <p>
        Ledger location: {inputs.ledger ? (isPolygon ? `Edge ${Number(ledgerLineIndex ?? 0) + 1}` : ledgerSide) : 'Freestanding / no ledger'}
      </p>
      <p>Beam support posts: {beamSupportPosts}</p>
      <p>Perimeter railing support posts: {perimeterSupportPosts} (open run {railingSupportRunLf.toFixed(0)} lf @ max {railingPostSpacingFt.toFixed(0)}ft, no ledger-edge posts)</p>
      <p>Railing: {Number.isFinite(railingLf) ? railingLf.toFixed(0) : '0'} lf</p>
      <p>Labor total: {money(laborTotal)}</p>
      <p class="mt-3 text-xs text-slate-500">Diagram is conceptual for quick review, not structural engineering.</p>
    </div>
  </div>
    </>
  )}
</section>
