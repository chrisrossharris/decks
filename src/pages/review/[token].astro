---
import AppLayout from '@/layouts/AppLayout.astro';
import { latestDesignInputs, latestEstimate, latestTakeoff, listProjectImages, recordShareViewByToken, resolveShareToken } from '@/lib/db/repo';
import { parseJsonObject } from '@/lib/utils/json';
import { money } from '@/lib/utils/format';

const token = Astro.params.token as string;
const share = await resolveShareToken(token);

if (!share) {
  return new Response('Review link is invalid or expired', { status: 404 });
}

const projectId = share.project_id as string;
const estimate = share.kind === 'estimate' ? await latestEstimate(projectId) : null;
const inputs = share.kind === 'blueprint' ? await latestDesignInputs(projectId) : null;
const takeoff = share.kind === 'blueprint' ? await latestTakeoff(projectId) : null;
const images = share.kind === 'blueprint' ? await listProjectImages(projectId) : [];
const normalizedInputs = parseJsonObject(inputs?.inputs_json, {});
const reviewInputs = normalizedInputs as any;
const polygonPoints = Array.isArray(reviewInputs.deck_polygon_points)
  ? reviewInputs.deck_polygon_points
      .map((p: any) => ({ x: Number(p?.x), y: Number(p?.y) }))
      .filter((p: any) => Number.isFinite(p.x) && Number.isFinite(p.y))
  : [];
const isPolygon = reviewInputs.shape_mode === 'polygon' && polygonPoints.length >= 3;
const polygonBounds = isPolygon
  ? {
      minX: Math.min(...polygonPoints.map((p: any) => p.x)),
      maxX: Math.max(...polygonPoints.map((p: any) => p.x)),
      minY: Math.min(...polygonPoints.map((p: any) => p.y)),
      maxY: Math.max(...polygonPoints.map((p: any) => p.y))
    }
  : null;
const lengthFt = Math.max(1, Number(isPolygon && polygonBounds ? polygonBounds.maxX - polygonBounds.minX : reviewInputs.deck_length_ft ?? 20));
const widthFt = Math.max(1, Number(isPolygon && polygonBounds ? polygonBounds.maxY - polygonBounds.minY : reviewInputs.deck_width_ft ?? 14));
const joistSpacingInInput = Number(reviewInputs.joist_spacing_in ?? 16);
const joistSpacingIn = String(reviewInputs.decking_material ?? '') === 'composite'
  ? Math.min(joistSpacingInInput, 12)
  : joistSpacingInInput;
const joistCount = Math.max(2, Math.ceil((lengthFt * 12) / Math.max(1, joistSpacingIn)));
const drawJoists = Math.max(2, Math.min(24, joistCount));
const frameMaxW = 260;
const frameMaxH = 120;
const frameOriginX = 24;
const frameOriginY = 20;
const scale = Math.min(frameMaxW / Math.max(lengthFt, 1), frameMaxH / Math.max(widthFt, 1));
const drawW = Math.max(40, Math.min(frameMaxW, Math.max(lengthFt, 1) * scale));
const drawH = Math.max(40, Math.min(frameMaxH, Math.max(widthFt, 1) * scale));
const x0 = frameOriginX + (frameMaxW - drawW) / 2;
const y0 = frameOriginY + (frameMaxH - drawH) / 2;
const x1 = x0 + drawW;
const y1 = y0 + drawH;
const polygonScreenPoints = isPolygon && polygonBounds
  ? polygonPoints.map((p: any) => ({
      x: x0 + ((p.x - polygonBounds.minX) / Math.max(1, polygonBounds.maxX - polygonBounds.minX)) * drawW,
      y: y1 - ((p.y - polygonBounds.minY) / Math.max(1, polygonBounds.maxY - polygonBounds.minY)) * drawH
    }))
  : [];
const polygonPointsAttr = polygonScreenPoints.map((p: any) => `${p.x},${p.y}`).join(' ');
const assumptions = parseJsonObject(takeoff?.assumptions_json, {} as Record<string, unknown>);
const constants = parseJsonObject((assumptions as any).constants, {} as Record<string, unknown>);
const beamCountInput = Math.max(1, Number(reviewInputs.beam_count ?? 1));
const beamCountEffectiveRaw = Number((constants as any).effective_beam_count ?? 0);
const beamCount = Number.isFinite(beamCountEffectiveRaw) && beamCountEffectiveRaw > 0
  ? Math.max(1, beamCountEffectiveRaw)
  : beamCountInput;
const postSpacingFt = Math.max(1, Number(reviewInputs.post_spacing_ft ?? 6));
const postCountPerBeamRaw = Number((constants as any).post_count_per_beam ?? 0);
const postCountPerBeam = Number.isFinite(postCountPerBeamRaw) && postCountPerBeamRaw > 0
  ? postCountPerBeamRaw
  : Math.max(2, Math.ceil(lengthFt / postSpacingFt) + 1);
const beamSupportPostsRaw = Number((constants as any).beam_support_post_count ?? 0);
const beamSupportPosts = Number.isFinite(beamSupportPostsRaw) && beamSupportPostsRaw > 0
  ? beamSupportPostsRaw
  : postCountPerBeam * beamCount;
const railingPostSpacingFt = Math.max(1, Number((constants as any).default_railing_post_spacing_ft ?? 6));
const ledgerSideRaw = String((reviewInputs as any).ledger_side ?? (constants as any).ledger_side ?? 'top').toLowerCase();
const ledgerSide = (ledgerSideRaw === 'right' || ledgerSideRaw === 'bottom' || ledgerSideRaw === 'left') ? ledgerSideRaw : 'top';
const ledgerLineIndexRaw = Number((reviewInputs as any).ledger_line_index ?? (constants as any).ledger_line_index ?? -1);
const ledgerLineIndex = isPolygon && Number.isFinite(ledgerLineIndexRaw) && ledgerLineIndexRaw >= 0
  ? Math.floor(ledgerLineIndexRaw) % Math.max(1, polygonPoints.length)
  : null;
const polygonHouseSideLengthFt = isPolygon && ledgerLineIndex !== null
  ? Math.hypot(
      (polygonPoints[(ledgerLineIndex + 1) % polygonPoints.length]?.x ?? 0) - (polygonPoints[ledgerLineIndex]?.x ?? 0),
      (polygonPoints[(ledgerLineIndex + 1) % polygonPoints.length]?.y ?? 0) - (polygonPoints[ledgerLineIndex]?.y ?? 0)
    )
  : 0;
const houseSideLengthFt = isPolygon
  ? polygonHouseSideLengthFt
  : (ledgerSide === 'left' || ledgerSide === 'right') ? Math.max(widthFt, 0) : Math.max(lengthFt, 0);
const outFromHouseFt = (ledgerSide === 'left' || ledgerSide === 'right') ? Math.max(lengthFt, 0) : Math.max(widthFt, 0);
const stairOpeningLf = Math.max(0, Number(reviewInputs.stair_count ?? 0) * Number(reviewInputs.stair_width_ft ?? 0));
const openRunFallback = Math.max(
  0,
  (reviewInputs.ledger ? Math.max((2 * (Math.max(lengthFt, 0) + Math.max(widthFt, 0))) - houseSideLengthFt, 0) : (2 * (Math.max(lengthFt, 0) + Math.max(widthFt, 0))))
    - stairOpeningLf
);
const railingSupportRunLfRaw = Number((constants as any).railing_support_run_lf ?? 0);
const railingSupportRunLf = Number.isFinite(railingSupportRunLfRaw) && railingSupportRunLfRaw > 0
  ? railingSupportRunLfRaw
  : openRunFallback;
const perimeterSupportPostsRaw = Number((constants as any).perimeter_railing_support_post_count ?? 0);
const perimeterSupportPosts = Number.isFinite(perimeterSupportPostsRaw) && perimeterSupportPostsRaw > 0
  ? perimeterSupportPostsRaw
  : Math.max(0, Math.ceil(railingSupportRunLf / railingPostSpacingFt) + 1);
const corners = [
  { x: x0, y: y1 }, // bottom-left
  { x: x1, y: y1 }, // bottom-right
  { x: x1, y: y0 }, // top-right (ledger corner)
  { x: x0, y: y0 } // top-left (ledger corner)
];
const perimeterFt = Math.max(1, Math.max(lengthFt, 1) + 2 * Math.max(widthFt, 1));
const perimeterPoints = (() => {
  if (isPolygon) {
    return polygonScreenPoints.slice(0, Math.min(polygonScreenPoints.length, 40));
  }
  const target = Math.max(0, Math.min(40, perimeterSupportPosts));
  if (target <= 0) return [] as Array<{ x: number; y: number }>;
  if (target <= 4) return corners.slice(0, target);

  const remaining = target - 4;
  const allSides = [
    { key: 'bottom', len: Math.max(lengthFt, 1), start: corners[0], end: corners[1] },
    { key: 'right', len: Math.max(widthFt, 1), start: corners[1], end: corners[2] },
    { key: 'top', len: Math.max(lengthFt, 1), start: corners[3], end: corners[2] },
    { key: 'left', len: Math.max(widthFt, 1), start: corners[3], end: corners[0] }
  ];
  const sideDefs = allSides.filter((s) => !(reviewInputs.ledger && s.key === ledgerSide));

  const quotas = sideDefs.map((s) => (remaining * s.len) / perimeterFt);
  const extras = quotas.map((q) => Math.floor(q));
  let allocated = extras.reduce((sum, n) => sum + n, 0);
  const remainders = quotas.map((q, i) => ({ i, rem: q - Math.floor(q) })).sort((a, b) => b.rem - a.rem);
  for (let r = 0; allocated < remaining && r < remainders.length; r += 1) {
    extras[remainders[r].i] += 1;
    allocated += 1;
  }

  const points: Array<{ x: number; y: number }> = [...corners];
  for (let sideIndex = 0; sideIndex < sideDefs.length; sideIndex += 1) {
    const side = sideDefs[sideIndex];
    const count = extras[sideIndex];
    for (let i = 1; i <= count; i += 1) {
      const t = i / (count + 1);
      points.push({
        x: side.start.x + (side.end.x - side.start.x) * t,
        y: side.start.y + (side.end.y - side.start.y) * t
      });
    }
  }

  return points.slice(0, target);
})();
const ledgerLine = (() => {
  if (!reviewInputs.ledger) return null;
  if (isPolygon && ledgerLineIndex !== null && polygonScreenPoints.length >= 2) {
    const a = polygonScreenPoints[ledgerLineIndex];
    const b = polygonScreenPoints[(ledgerLineIndex + 1) % polygonScreenPoints.length];
    if (!a || !b) return null;
    return {
      x1: a.x,
      y1: a.y,
      x2: b.x,
      y2: b.y,
      lx: (a.x + b.x) / 2 - 32,
      ly: (a.y + b.y) / 2 - 8
    };
  }
  if (ledgerSide === 'right') return { x1: x1, y1: y0, x2: x1, y2: y1, lx: x1 - 36, ly: y0 - 8 };
  if (ledgerSide === 'bottom') return { x1: x0, y1: y1, x2: x1, y2: y1, lx: x0, ly: y1 + 12 };
  if (ledgerSide === 'left') return { x1: x0, y1: y0, x2: x0, y2: y1, lx: x0, ly: y0 - 8 };
  return { x1: x0, y1: y0, x2: x1, y2: y0, lx: x0, ly: y0 - 8 };
})();
const submitted = Astro.url.searchParams.get('submitted') === '1';
const fmt = (value: unknown, suffix = '') => {
  const n = Number(value);
  if (!Number.isFinite(n)) return 'N/A';
  return `${n}${suffix}`;
};
if (share.kind === 'estimate') {
  await recordShareViewByToken(token);
}
---

<AppLayout title={`Client Review - ${share.project_name}`}>
  <section class="card p-5">
    <p class="text-xs font-semibold uppercase tracking-[0.2em] text-pine">Client Review Link</p>
    <h2 class="mt-1 font-display text-2xl font-bold">{share.project_name}</h2>
    <p class="mt-1 text-sm text-slate-600">Review type: <span class="font-semibold">{share.kind}</span></p>
  </section>

  {share.kind === 'estimate' ? (
    <section class="mt-4 card p-5 text-sm">
      <h3 class="font-display text-xl font-semibold">Estimate Summary</h3>
      {submitted && (
        <div class="alert-success mt-3">
          Response submitted. The contractor has been notified.
        </div>
      )}
      {estimate ? (
        <div class="mt-3 grid gap-2 sm:grid-cols-2">
          <p>Materials: {money(estimate.subtotal_materials)}</p>
          <p>Labor: {money(estimate.subtotal_labor)}</p>
          <p>Overhead: {money(estimate.overhead_amount)}</p>
          <p>Profit: {money(estimate.profit_amount)}</p>
          <p>Tax: {money(estimate.tax_amount)}</p>
          <p class="font-semibold">Total: {money(estimate.grand_total)}</p>
        </div>
      ) : (
        <p class="mt-3">No estimate has been finalized for this project yet.</p>
      )}

      <form class="mt-4 grid gap-3 border-t border-slate-800 pt-4" method="post" action={`/api/review/${token}/respond`}>
        <h4 class="font-semibold">Client Decision</h4>
        <label>
          <p class="label">Your Name</p>
          <input class="input" name="reviewer_name" required />
        </label>
        <label>
          <p class="label">Email (optional)</p>
          <input class="input" type="email" name="reviewer_email" />
        </label>
        <label>
          <p class="label">Decision</p>
          <select class="input" name="decision" required>
            <option value="approved">Approve</option>
            <option value="changes_requested">Request Changes</option>
          </select>
        </label>
        <label>
          <p class="label">Approved Amount (optional)</p>
          <input class="input" name="approved_amount" type="number" step="0.01" min="0" />
        </label>
        <label>
          <p class="label">Notes</p>
          <textarea class="input min-h-[90px]" name="message" placeholder="Comments, requested edits, or conditions"></textarea>
        </label>
        <button class="w-fit rounded-md bg-pine px-4 py-2 text-sm font-semibold text-white">Submit Decision</button>
      </form>
    </section>
  ) : (
    <>
      <section class="mt-4 card p-5">
        <h3 class="font-display text-xl font-semibold">Blueprint Inputs</h3>
        {inputs ? (
          <div class="mt-3 grid gap-3 text-sm">
            <div class="grid gap-3 sm:grid-cols-2">
            <div class="rounded-lg border border-slate-800 p-3">
              <p class="font-semibold">Deck Geometry</p>
              <p class="mt-1 text-slate-600">Mode: {String((normalizedInputs as any).shape_mode ?? 'rectangle')}</p>
              <p class="text-slate-600">Length: {fmt((normalizedInputs as any).deck_length_ft, ' ft')}</p>
              <p class="text-slate-600">Width: {fmt((normalizedInputs as any).deck_width_ft, ' ft')}</p>
              <p class="text-slate-600">Height: {fmt((normalizedInputs as any).deck_height_ft, ' ft')}</p>
            </div>
            <div class="rounded-lg border border-slate-800 p-3">
              <p class="font-semibold">Framing</p>
              <p class="mt-1 text-slate-600">Joist spacing: {fmt((normalizedInputs as any).joist_spacing_in, ' in')}</p>
              <p class="text-slate-600">Beam count: {fmt((normalizedInputs as any).beam_count)}</p>
              <p class="text-slate-600">Post spacing: {fmt((normalizedInputs as any).post_spacing_ft, ' ft')}</p>
              <p class="text-slate-600">Ledger: {(normalizedInputs as any).ledger ? 'Yes' : 'No'}</p>
              <p class="text-slate-600">Ledger side: {String((normalizedInputs as any).ledger_side ?? 'top')}</p>
              {isPolygon && (
                <p class="text-slate-600">Ledger edge: {Number.isFinite(Number((normalizedInputs as any).ledger_line_index)) ? Number((normalizedInputs as any).ledger_line_index) + 1 : 1}</p>
              )}
            </div>
            <div class="rounded-lg border border-slate-800 p-3">
              <p class="font-semibold">Decking + Rail</p>
              <p class="mt-1 text-slate-600">Material: {String((normalizedInputs as any).decking_material ?? 'N/A')}</p>
              <p class="text-slate-600">Board width: {fmt((normalizedInputs as any).decking_board_width_in, ' in')}</p>
              <p class="text-slate-600">Railing type: {String((normalizedInputs as any).railing_type ?? 'N/A')}</p>
              <p class="text-slate-600">Stairs: {fmt((normalizedInputs as any).stair_count)}</p>
            </div>
            <div class="rounded-lg border border-slate-800 p-3">
              <p class="font-semibold">Cover</p>
              <p class="mt-1 text-slate-600">Covered: {(normalizedInputs as any).is_covered ? 'Yes' : 'No'}</p>
              <p class="text-slate-600">Roof type: {String((normalizedInputs as any).roof_type ?? 'N/A')}</p>
              <p class="text-slate-600">Roof length: {fmt((normalizedInputs as any).roof_length_ft, ' ft')}</p>
              <p class="text-slate-600">Roof width: {fmt((normalizedInputs as any).roof_width_ft, ' ft')}</p>
            </div>
            </div>

            <div class="rounded-lg border border-slate-800 p-3">
              <p class="font-semibold">Framing Diagram</p>
              <svg viewBox="0 0 320 200" class="mt-2 w-full">
                <defs>
                  {isPolygon && polygonPointsAttr && (
                    <clipPath id="review-deck-shape-clip">
                      <polygon points={polygonPointsAttr}></polygon>
                    </clipPath>
                  )}
                </defs>
                {isPolygon && polygonPointsAttr ? (
                  <polygon points={polygonPointsAttr} fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.7"></polygon>
                ) : (
                  <rect x={x0} y={y0} width={drawW} height={drawH} fill="none" stroke="currentColor" stroke-width="1.5" opacity="0.7"></rect>
                )}
                {ledgerLine && (
                  <text x={ledgerLine.lx} y={ledgerLine.ly} font-size="10" fill="#0f766e">
                    House / ledger side ({isPolygon ? `edge ${Number(ledgerLineIndex ?? 0) + 1}` : ledgerSide})
                  </text>
                )}
                <g clip-path={isPolygon && polygonPointsAttr ? 'url(#review-deck-shape-clip)' : undefined}>
                  {Array.from({ length: drawJoists }).map((_, i) => (
                    <line x1={x0 + (drawW * i) / (drawJoists - 1)} y1={y0} x2={x0 + (drawW * i) / (drawJoists - 1)} y2={y1} stroke="#94a3b8" stroke-width="0.8"></line>
                  ))}
                </g>
                {drawJoists > 1 && (
                  <>
                    <line x1={x0} y1={y1 + 10} x2={x0 + (drawW / (drawJoists - 1))} y2={y1 + 10} stroke="#334155" stroke-width="1" />
                    <line x1={x0} y1={y1 + 7} x2={x0} y2={y1 + 13} stroke="#334155" stroke-width="1" />
                    <line x1={x0 + (drawW / (drawJoists - 1))} y1={y1 + 7} x2={x0 + (drawW / (drawJoists - 1))} y2={y1 + 13} stroke="#334155" stroke-width="1" />
                    <text x={x0 + (drawW / (drawJoists - 1)) / 2 - 14} y={y1 + 21} font-size="8" fill="#334155">{joistSpacingIn}" O.C.</text>
                  </>
                )}
                {ledgerLine && (
                  <line x1={ledgerLine.x1} y1={ledgerLine.y1} x2={ledgerLine.x2} y2={ledgerLine.y2} stroke="#0f766e" stroke-width="3"></line>
                )}
                <g clip-path={isPolygon && polygonPointsAttr ? 'url(#review-deck-shape-clip)' : undefined}>
                  {Array.from({ length: beamCount }).map((_, i) => (
                    <line x1={x0} y1={y1 - (drawH * (i + 1)) / (beamCount + 1)} x2={x1} y2={y1 - (drawH * (i + 1)) / (beamCount + 1)} stroke="#b45309" stroke-width="2"></line>
                  ))}
                  {Array.from({ length: beamCount }).flatMap((_, b) => {
                    const py = y1 - (drawH * (b + 1)) / (beamCount + 1);
                    return Array.from({ length: postCountPerBeam }).map((__, p) => (
                      <circle cx={x0 + (drawW * p) / Math.max(postCountPerBeam - 1, 1)} cy={py} r="2.4" fill="#1d4ed8"></circle>
                    ));
                  })}
                </g>
                {perimeterPoints.map((p) => (
                  <circle cx={p.x} cy={p.y} r="2.2" stroke="#1d4ed8" stroke-width="1" fill="#ffffff"></circle>
                ))}
                <text x={x0} y="178" font-size="10" fill="currentColor">Length (along house): {houseSideLengthFt.toFixed(1)} ft</text>
                <text x={x0} y="190" font-size="10" fill="currentColor">Depth (out from house): {outFromHouseFt.toFixed(1)} ft</text>
              </svg>
              <div class="mt-2 flex flex-wrap gap-3 text-xs text-slate-600">
                <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-slate-400"></span>Joist</span>
                <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-amber-700"></span>Beam</span>
                <span class="inline-flex items-center gap-1"><span class="h-0.5 w-4 bg-teal-700"></span>Ledger</span>
                <span class="inline-flex items-center gap-1"><span class="h-2 w-2 rounded-full bg-blue-700"></span>Beam support post</span>
                <span class="inline-flex items-center gap-1"><span class="h-2 w-2 rounded-full border border-blue-700 bg-white"></span>Perimeter railing support post</span>
              </div>
              <p class="mt-2 text-xs text-slate-500">
                Joists: {joistCount} @ {joistSpacingIn}" O.C. | Beams: {beamCount}{beamCount !== beamCountInput ? ` (auto from ${beamCountInput})` : ''} | Beam support posts: {beamSupportPosts} | Perimeter railing support posts: {perimeterSupportPosts} (open run {railingSupportRunLf.toFixed(0)} lf @ max {railingPostSpacingFt.toFixed(0)}ft, no ledger-edge posts)
              </p>
              <p class="text-xs text-slate-500">
                Ledger location: {reviewInputs.ledger ? (isPolygon ? `Edge ${Number(ledgerLineIndex ?? 0) + 1}` : ledgerSide) : 'Freestanding / no ledger'}
              </p>
            </div>
          </div>
        ) : (
          <p class="mt-3 text-sm text-slate-600">No design input version found.</p>
        )}
      </section>

      <section class="mt-4 grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
        {images.length === 0 ? (
          <div class="card p-4 text-sm text-slate-600">No project images uploaded.</div>
        ) : images.map((image: any) => (
          <article class="card overflow-hidden">
            <img src={`/review/${token}/image/${image.id}`} alt={image.caption || image.file_name} class="h-48 w-full object-cover" />
            <div class="p-3">
              <p class="text-sm font-semibold">{image.file_name}</p>
              <p class="text-xs text-slate-500">{image.caption || 'No caption'}</p>
            </div>
          </article>
        ))}
      </section>
    </>
  )}
</AppLayout>
